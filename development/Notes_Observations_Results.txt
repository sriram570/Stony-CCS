Observations on PacBio's consensus generation
=============================================

1. Scoring function used for vertices --> (2 * numReads[v] - coverage[v] - epsilon)
    where,
        epsilon -  0.0001
        numReads[v] (or) containingReads
            - number of reads going through node 'v'
        coverage[v] (or) SpanningReads
            - number of reads that pass through 'v' + 
                number of other reads which pass through at least one ancestor and one descendant
                 of 'v'
            - PacBio uses a "tagSpan" approach to calculate coverage of a vertex,
              i.e. whenever a read is added, the spanning coverage of all vertices "covered" by 
              the read are incremented.

2. Consensus generation
-----------------------
    Consensus is calculated by looking for a path maximizing the score determined as a
    sum of vertex scores obtained using the above scoring function.

3. Scoring function used by PacBio is implemented in the following link.
    https://github.com/PacificBiosciences/unanimity/blob/1c091914c9615db49d26f270add9498fea3de3b3/src/poa/PoaGraphTraversals.cpp#L114



POA graph traversals for consensus generation
=============================================

This section describes the various node selection algorithms used to determine the starting node
from which the backtracking traversal starts building the consensus sequence.

1. Max Score Node
-----------------

    -   start the backtracking traversal from the node with maximum score to generate the
        consensus sequence.

    -   if more than one such node exists, chose the one with max index number (as the nodes are
        topologically sorted and the last such node would have the max index value).


2. Max Incoming Edge
--------------------

    -   instead of backtracking from the node with maximum score, a node with maximum
        incoming edge is chosen for backtracking and building the consensus.

    -   nodes with maximum incoming edges are more likely to be the most important nodes in the
        POA graph as most reads would pass through them. Thus, can backtrack from one such node.

    -   if more than one such node exists, chose the one with max index number (as the nodes are
        topologically sorted and the last such node would have the max index value).


3. Random Heuristic based Node Selection
----------------------------------------

    -   identify the node with max score (max_score)
    -   fix a optimal value of range (w.r.t max_score)

    -   find a subset of nodes such that
            (max_score - range) <= score(node) <= max_score
            i.e. find all nodes having scores within a given range of max_score

    -   randomly select a node from the subset
    -   backtrack from the selected node to build consensus


4. Max Sequence based Node Selection
------------------------------------

    -   identify the node containing maximum number of sequences and backtrack from that node
        to build the consensus.

    -   if more than one such node exists, chose the one with max index number (as the nodes are
        topologically sorted and the last such node would have the max index value). 


5. Optimized Random Heuristic
-----------------------------

    -   find a subset of nodes within a specific score range as in method 3.

    -   from the subset, choose a node with max number of incoming edges as in method 2.



Scoring functions
=================

This section elaborates the scoring function used to build the CCS.

1. Edge weight based Scoring function
-------------------------------------

    In this scoring function, the score of a node is calculated using the following steps:
     -  Identifying "node": finding the best predecessor node, i.e. the source node of an incoming
        edge which has maximum weight (weight of an edge is calculated as the total number of
        reads passing through both the endpoint nodes connected by the edge)

     -  Extracting "Score(node)": once the best predecessor node is identified, extract its score
        Note:
        ====
        We are assured to have the score of a node's predecessor computed before computing the
        score of the current node and all of its successors because we traverse the POA graph in a
        "topologically sorted" order.

     -  Now, score of "current node" is computed as the sum of the score of its "best predecessor
        node" and the edge weight between these two nodes as follows

            Score(node) = Score(best_predecessor_node) + Edge_weight(best_predecessor_node, node)


2. PacBio like Scoring function
-------------------------------

    Here, the scoring function is computed as follows:
        Score(node) = 2*#contained_reads - #outgoing_edges

    Note:
    ====
    '#outgoing_edges' is different from the 'Span' used by PacBio (defined at the top of this doc)
    '#contained_reads' is the total number of reads that pass through the given node